{"_id":"chai-immutable","_rev":"35-555ce3da6d679b4ceb08351b0cbe579b","name":"chai-immutable","time":{"modified":"2019-03-19T03:32:10.233Z","created":"2015-03-06T05:35:53.140Z","0.1.0":"2015-03-06T05:35:53.140Z","0.2.0":"2015-03-06T06:12:35.262Z","0.2.1":"2015-03-07T06:25:06.646Z","0.3.0":"2015-03-16T04:23:55.523Z","1.0.0":"2015-06-02T00:29:08.759Z","1.0.1":"2015-06-04T14:57:59.972Z","1.0.2":"2015-06-09T04:04:26.087Z","1.1.0":"2015-07-03T21:37:30.847Z","1.1.1":"2015-07-07T22:51:51.409Z","1.2.0":"2015-07-09T23:45:09.819Z","1.3.0":"2015-08-16T20:19:41.260Z","1.4.0":"2015-10-27T04:51:43.382Z","1.5.0":"2015-10-31T17:05:37.342Z","1.5.1":"2015-11-02T04:47:35.304Z","1.5.2":"2015-11-06T06:13:57.905Z","1.5.3":"2015-11-19T05:37:10.452Z","1.5.4":"2016-03-24T23:34:00.656Z","1.6.0":"2016-06-11T04:43:55.769Z","2.0.0-alpha.1":"2017-07-27T06:28:51.863Z","2.0.0-alpha.2":"2018-05-20T16:12:15.409Z","2.0.0-rc.1":"2018-05-29T04:49:42.453Z","2.0.0-rc.2":"2018-05-29T06:33:16.546Z","2.0.0-rc.3":"2018-11-11T05:18:41.960Z","2.0.0":"2019-03-19T03:17:19.052Z"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"dist-tags":{"latest":"2.0.0"},"description":"Chai assertions for Facebook's Immutable library for JavaScript collections","readme":"[![npm Version](https://img.shields.io/npm/v/chai-immutable.svg)](https://npmjs.org/package/chai-immutable)\n[![License](https://img.shields.io/npm/l/chai-immutable.svg)](LICENSE)\n[![Build Status](https://travis-ci.org/astorije/chai-immutable.svg?branch=master)](https://travis-ci.org/astorije/chai-immutable)\n[![Build Status](https://ci.appveyor.com/api/projects/status/407ts84pq7wd4kt9/branch/master?svg=true)](https://ci.appveyor.com/project/astorije/chai-immutable/branch/master)\n[![Coverage Status](https://coveralls.io/repos/astorije/chai-immutable/badge.svg)](https://coveralls.io/r/astorije/chai-immutable)\n[![devDependencies Status](https://david-dm.org/astorije/chai-immutable/dev-status.svg)](https://david-dm.org/astorije/chai-immutable?type=dev)\n[![peerDependencies Status](https://david-dm.org/astorije/chai-immutable/peer-status.svg)](https://david-dm.org/astorije/chai-immutable?type=peer)\n\n# Chai Immutable\n\nThis plugin provides a set of [Chai](http://chaijs.com/) assertions for [Facebook's Immutable library for JavaScript collections](http://facebook.github.io/immutable-js/).\n\n<!-- fulky:globals\nconst chai = require('chai');\nconst { assert, expect } = chai;\n\nconst Immutable = require('immutable');\nconst {\n  List,\n  Map,\n  Set,\n  Stack,\n} = Immutable;\n\nchai.use(require('./chai-immutable'));\n-->\n\n## Installation\n\n### Node.js\n\nInstall via [npm](http://npmjs.org) or [yarn](https://yarnpkg.com/):\n\n```bash\nnpm install --save-dev chai-immutable\nyarn add --dev chai-immutable\n```\n\nYou can then use this plugin as any other Chai plugins:\n\n<!-- fulky:skip-test -->\n\n```js\nconst chai = require('chai');\nconst chaiImmutable = require('chai-immutable');\n\nchai.use(chaiImmutable);\n```\n\n### ES6 syntax (needs Babel transpiling)\n\n<!-- fulky:skip-test -->\n\n```js\nimport chai from 'chai';\nimport chaiImmutable from 'chai-immutable';\n\nchai.use(chaiImmutable);\n```\n\n### In the browser\n\nInclude this plugin after including Chai and Immutable. It will automatically\nplug in to Chai and be ready for use:\n\n```html\n<script src=\"chai-immutable.js\"></script>\n```\n\n### Using `chai-immutable` with other plugins\n\nIf you are using this plugin with\n[`chai-as-promised`](https://github.com/domenic/chai-as-promised/) or\n[`dirty-chai`](https://github.com/prodatakey/dirty-chai), note that\n`chai-immutable` must be loaded **before** any of them. For example:\n\n<!-- fulky:skip-test -->\n\n```js\nconst chai = require('chai');\nconst chaiAsPromised = require('chai-as-promised');\nconst chaiImmutable = require('chai-immutable');\nconst dirtyChai = require('dirty-chai');\nconst { expect } = chai;\n\nchai.use(chaiImmutable);\nchai.use(chaiAsPromised);\nchai.use(dirtyChai);\n\nconst { List } = require('immutable');\n\n/* ... */\n\nexpect(Promise.resolve(List.of(1, 2, 3))).to.eventually.have.size(3);\nexpect(true).to.be.true();\n```\n\n## BDD API Reference\n\n### .empty\n\nAsserts that the immutable collection is empty.\n\n```js\nexpect(List()).to.be.empty;\nexpect(List.of(1, 2, 3)).to.not.be.empty;\n```\n\n### .equal(collection)\n\n- **@param** _{ Collection }_ collection\n\nAsserts that the values of the target are equivalent to the values of\n`collection`. Aliases of Chai's original `equal` method are also supported.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(1, 2, 3);\nexpect(a).to.equal(b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\nAlso, note that `deep.equal` and `eql` are synonyms of `equal` when\ntested against immutable data structures, therefore they are aliases to\n`equal`.\n\n### .include(value)\n\n- **@param** _{ Mixed }_ val\n\nThe `include` and `contain` assertions can be used as either property\nbased language chains or as methods to assert the inclusion of a value or\nsubset in an immutable collection. When used as language chains, they toggle\nthe `contains` flag for the `keys` assertion.\n\nNote that `deep.include` behaves exactly like `include` in the context of\nimmutable data structures.\n\n```js\nexpect(new List([1, 2, 3])).to.include(2);\nexpect(new List([1, 2, 3])).to.deep.include(2);\nexpect(new Map({ foo: 'bar', hello: 'world' })).to.include('bar');\nexpect(new Map({ a: 1, b: 2, c: 3 })).to.include(new Map({ a: 1, b: 2 }));\nexpect(new Map({ foo: 'bar', hello: 'world' })).to.include.keys('foo');\n```\n\n### .keys(key1[, key2[, ...]])\n\n- **@param** _{ String... | Array | Object | Collection }_ key*N*\n\nAsserts that the target collection has the given keys.\n\nWhen the target is an object or array, keys can be provided as one or more\nstring arguments, a single array argument, a single object argument, or an\nimmutable collection. In the last 2 cases, only the keys in the given\nobject/collection matter; the values are ignored.\n\n```js\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys('foo', 'bar');\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new List(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Set(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Stack(['bar', 'foo']));\nexpect(new List(['x', 'y'])).to.have.all.keys(0, 1);\n\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(['foo', 'bar']);\nexpect(new List(['x', 'y'])).to.have.all.keys([0, 1]);\n\n// Values in the passed object are ignored:\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys({ bar: 6, foo: 7 });\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(\n  new Map({ bar: 6, foo: 7 })\n);\nexpect(new List(['x', 'y'])).to.have.all.keys({ 0: 4, 1: 5 });\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nBy default, the target must have all of the given keys and no more. Add\n`.any` earlier in the chain to only require that the target have at least\none of the given keys. Also, add `.not` earlier in the chain to negate\n`.keys`. It's often best to add `.any` when negating `.keys`, and to use\n`.all` when asserting `.keys` without negation.\n\nWhen negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\nexactly what's expected of the output, whereas `.not.all.keys` creates\nuncertain expectations.\n\n```js\n// Recommended; asserts that target doesn't have any of the given keys\nexpect(new Map({ a: 1, b: 2 })).to.not.have.any.keys('c', 'd');\n\n// Not recommended; asserts that target doesn't have all of the given\n// keys but may or may not have some of them\nexpect(new Map({ a: 1, b: 2 })).to.not.have.all.keys('c', 'd');\n```\n\nWhen asserting `.keys` without negation, `.all` is preferred because\n`.all.keys` asserts exactly what's expected of the output, whereas\n`.any.keys` creates uncertain expectations.\n\n```js\n// Recommended; asserts that target has all the given keys\nexpect(new Map({ a: 1, b: 2 })).to.have.all.keys('a', 'b');\n\n// Not recommended; asserts that target has at least one of the given\n// keys but may or may not have more of them\nexpect(new Map({ a: 1, b: 2 })).to.have.any.keys('a', 'b');\n```\n\nNote that `.all` is used by default when neither `.all` nor `.any` appear\nearlier in the chain. However, it's often best to add `.all` anyway because\nit improves readability.\n\n```js\n// Both assertions are identical\nexpect(new Map({ a: 1, b: 2 })).to.have.all.keys('a', 'b'); // Recommended\nexpect(new Map({ a: 1, b: 2 })).to.have.keys('a', 'b'); // Not recommended\n```\n\nAdd `.include` earlier in the chain to require that the target's keys be a\nsuperset of the expected keys, rather than identical sets.\n\n```js\n// Target object's keys are a superset of ['a', 'b'] but not identical\nexpect(new Map({ a: 1, b: 2, c: 3 })).to.include.all.keys('a', 'b');\nexpect(new Map({ a: 1, b: 2, c: 3 })).to.not.have.all.keys('a', 'b');\n```\n\nHowever, if `.any` and `.include` are combined, only the `.any` takes\neffect. The `.include` is ignored in this case.\n\n```js\n// Both assertions are identical\nexpect(new Map({ a: 1 })).to.have.any.keys('a', 'b');\nexpect(new Map({ a: 1 })).to.include.any.keys('a', 'b');\n```\n\nThe alias `.key` can be used interchangeably with `.keys`.\n\n```js\nexpect(new Map({ foo: 1 })).to.have.key('foo');\n```\n\n### .property(path[, val])\n\n- **@param** _{ String | Array | Iterable }_ path\n- **@param** _{ Mixed }_ val (optional)\n\nAsserts that the target has a property with the given `path`.\n\n```js\nexpect(new Map({ a: 1 })).to.have.property('a');\n```\n\nWhen `val` is provided, `.property` also asserts that the property's value\nis equal to the given `val`. `val` can be an immutable collection.\n\n```js\nexpect(new Map({ a: 1 })).to.have.property('a', 1);\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nAdd `.nested` earlier in the chain to enable dot- and bracket-notation when\nreferencing nested properties. An immutable `List` can also be used as the\nstarting point of a `nested.property`.\n\n```js\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  'a.b[1]'\n);\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  'a.b[1]',\n  'y'\n);\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  ['a', 'b', 1],\n  'y'\n);\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  new List(['a', 'b', 1]),\n  'y'\n);\n```\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n```js\nexpect(Immutable.fromJS({ '.a': { '[b]': 'x' } })).to.have.nested.property(\n  '\\\\.a.\\\\[b\\\\]'\n);\n```\n\nAdd `.not` earlier in the chain to negate `.property`.\n\n```js\nexpect(new Map({ a: 1 })).to.not.have.property('b');\n```\n\nHowever, it's dangerous to negate `.property` when providing `val`. The\nproblem is that it creates uncertain expectations by asserting that the\ntarget either doesn't have a property at the given `path`, or that it\ndoes have a property at the given key `path` but its value isn't equal to\nthe given `val`. It's often best to identify the exact output that's\nexpected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn't expected to have a property at the given\n`path`, it's often best to assert exactly that.\n\n```js\nexpect(new Map({ b: 2 })).to.not.have.property('a'); // Recommended\nexpect(new Map({ b: 2 })).to.not.have.property('a', 1); // Not recommended\n```\n\nWhen the target is expected to have a property at the given key `path`,\nit's often best to assert that the property has its expected value, rather\nthan asserting that it doesn't have one of many unexpected values.\n\n```js\nexpect(new Map({ a: 3 })).to.have.property('a', 3); // Recommended\nexpect(new Map({ a: 3 })).to.not.have.property('a', 1); // Not recommended\n```\n\n`.property` changes the target of any assertions that follow in the chain\nto be the value of the property from the original target object.\n\n```js\nexpect(new Map({ a: 1 }))\n  .to.have.property('a')\n  .that.is.a('number');\n```\n\n### .size(value)\n\n- **@param** _{ Number }_ size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size(3);\n```\n\nIt can also be used as a chain precursor to a value comparison for the\n`size` property.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size.least(3);\nexpect(List.of(1, 2, 3)).to.have.size.most(3);\nexpect(List.of(1, 2, 3)).to.have.size.above(2);\nexpect(List.of(1, 2, 3)).to.have.size.below(4);\nexpect(List.of(1, 2, 3)).to.have.size.within(2, 4);\n```\n\nSimilarly to `length`/`lengthOf`, `sizeOf` is an alias of `size`:\n\n```js\nexpect(List.of(1, 2, 3)).to.have.sizeOf(3);\n```\n\n## TDD API Reference\n\n### .equal(actual, expected)\n\n- **@param** _{ Collection }_ actual\n- **@param** _{ Collection }_ expected\n\nAsserts that the values of `actual` are equivalent to the values of\n`expected`. Note that `.strictEqual()` and `.deepEqual()` assert\nexactly like `.equal()` in the context of Immutable data structures.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(1, 2, 3);\nassert.equal(a, b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`, `.strictEqual()` or `.deepEqual()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\n### .notEqual(actual, expected)\n\n- **@param** _{ Collection }_ actual\n- **@param** _{ Collection }_ expected\n\nAsserts that the values of `actual` are not equivalent to the values of\n`expected`. Note that `.notStrictEqual()` and `.notDeepEqual()` assert\nexactly like `.notEqual()` in the context of Immutable data structures.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(4, 5, 6);\nassert.notEqual(a, b);\n```\n\n### .sizeOf(collection, length)\n\n- **@param** _{ Collection }_ collection\n- **@param** _{ Number }_ size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nassert.sizeOf(List.of(1, 2, 3), 3);\nassert.sizeOf(new List(), 0);\n```\n","versions":{"0.2.0":{"name":"chai-immutable","version":"0.2.0","description":"Chai assertions for Immutable","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"test":"mocha","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","devDependencies":{"chai":"2.x.x","coveralls":"2.x.x","immutable":"3.x.x","istanbul":"0.3.x","mocha":"2.x.x"},"gitHead":"29215d23f5878fb97aa71a95fa668cebab84cb64","_id":"chai-immutable@0.2.0","_shasum":"a7e32b292562014ca3725f3972701d6b0f6533fa","_from":".","_npmVersion":"2.3.0","_nodeVersion":"0.10.25","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"dist":{"shasum":"a7e32b292562014ca3725f3972701d6b0f6533fa","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-0.2.0.tgz"}},"0.2.1":{"name":"chai-immutable","version":"0.2.1","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"test":"mocha","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","devDependencies":{"chai":"2.x.x","coveralls":"2.x.x","immutable":"3.x.x","istanbul":"0.3.x","mocha":"2.x.x"},"gitHead":"242c613b2c04335d7ddb8700a280992d19034f95","_id":"chai-immutable@0.2.1","_shasum":"92d263955cead3d85255ce1824f0d82f89aa9e03","_from":".","_npmVersion":"2.5.1","_nodeVersion":"0.12.0","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"dist":{"shasum":"92d263955cead3d85255ce1824f0d82f89aa9e03","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-0.2.1.tgz"}},"0.3.0":{"name":"chai-immutable","version":"0.3.0","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run check-style && mocha","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","devDependencies":{"chai":"2.x.x","coveralls":"2.x.x","immutable":"3.x.x","istanbul":"0.3.x","jscs":"1.x.x","mocha":"2.x.x"},"gitHead":"8d720415290983d6df6ab9caaf55b8de26b5f9b5","_id":"chai-immutable@0.3.0","_shasum":"dd8ee854a5ee163840a5876c9fbb76efb3ab7960","_from":".","_npmVersion":"2.3.0","_nodeVersion":"0.11.16","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"dist":{"shasum":"dd8ee854a5ee163840a5876c9fbb76efb3ab7960","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-0.3.0.tgz"}},"1.0.2":{"name":"chai-immutable","version":"1.0.2","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run check-style && mocha","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","devDependencies":{"chai":"^2.3.0","coveralls":"^2.11.2","immutable":"^3.7.3","istanbul":"^0.3.14","jscs":"^1.13.1","mocha":"^2.2.5"},"gitHead":"4027ae13758ada4cdb01d2fedd7c671f05bcff45","_id":"chai-immutable@1.0.2","_shasum":"d535d59f17770bb6bb58242478ecaee501728c05","_from":".","_npmVersion":"2.10.1","_nodeVersion":"0.12.4","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"dist":{"shasum":"d535d59f17770bb6bb58242478ecaee501728c05","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.0.2.tgz"}},"1.1.1":{"name":"chai-immutable","version":"1.1.1","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run check-style && mocha","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","devDependencies":{"chai":"^2.3.0","coveralls":"^2.11.2","immutable":"^3.7.3","istanbul":"^0.3.14","jscs":"^1.13.1","mocha":"^2.2.5"},"gitHead":"a5b6b465a6ddf79b5dd9479d79b9e821d0588a7c","_id":"chai-immutable@1.1.1","_shasum":"7f2b8f5ea0bf7022f9cd0c721386d14f7dd95322","_from":".","_npmVersion":"2.12.1","_nodeVersion":"0.12.6","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"7f2b8f5ea0bf7022f9cd0c721386d14f7dd95322","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.1.1.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}]},"1.2.0":{"name":"chai-immutable","version":"1.2.0","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run check-style && mocha","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","devDependencies":{"chai":"^2.3.0","coveralls":"^2.11.2","immutable":"^3.7.3","istanbul":"^0.3.14","jscs":"^1.13.1","mocha":"^2.2.5"},"gitHead":"1440a1fa5b97d02f82ca4350862a5b78412c7f67","_id":"chai-immutable@1.2.0","_shasum":"071702d41d0eb39e9664b9feb2001a2e665530b2","_from":".","_npmVersion":"2.11.2","_nodeVersion":"0.12.6","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"dist":{"shasum":"071702d41d0eb39e9664b9feb2001a2e665530b2","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.2.0.tgz"}},"1.3.0":{"name":"chai-immutable","version":"1.3.0","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"mocha && npm run test-phantomjs && npm run check-style","test-phantomjs":"mocha-phantomjs test/index.html","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":">= 2.0.0 < 4"},"devDependencies":{"chai":"^2.3.0","coveralls":"^2.11.2","immutable":"^3.7.3","istanbul":"^0.3.14","jscs":"^1.13.1","mocha":"^2.2.5","mocha-phantomjs":"^3.6.0"},"gitHead":"d0c2ee43df30eb8db201bf5a67206c89639e17e2","_id":"chai-immutable@1.3.0","_shasum":"87839f05e097d1e9c603f8ca8fef8b0007022bc1","_from":".","_npmVersion":"2.12.1","_nodeVersion":"0.12.7","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"87839f05e097d1e9c603f8ca8fef8b0007022bc1","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.3.0.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}]},"1.4.0":{"name":"chai-immutable","version":"1.4.0","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run test-mocha; npm run test-phantomjs; npm run check-style","test-mocha":"mocha","test-phantomjs":"mocha-phantomjs test/index.html","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":">= 2.0.0 < 4"},"devDependencies":{"chai":"^3.2.0","coveralls":"^2.11.2","immutable":"^3.7.3","istanbul":"^0.4.0","jscs":"^2.1.1","mocha":"^2.2.5","mocha-phantomjs":"^4.0.1"},"gitHead":"ebc04997a810940b2fef29657f400bb2c8c42218","_id":"chai-immutable@1.4.0","_shasum":"a0b7905c3fb9124b85f8e3d3ea9cc1d74c3060b4","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"a0b7905c3fb9124b85f8e3d3ea9cc1d74c3060b4","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.4.0.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}]},"1.5.0":{"name":"chai-immutable","version":"1.5.0","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run test-mocha; npm run test-phantomjs; npm run check-style","test-mocha":"mocha","test-phantomjs":"mocha-phantomjs test/index.html","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":">= 2.0.0 < 4"},"devDependencies":{"chai":"^3.2.0","coveralls":"^2.11.2","immutable":"^3.7.3","istanbul":"^0.4.0","jscs":"^2.1.1","mocha":"^2.2.5","mocha-phantomjs":"^4.0.1"},"gitHead":"f4cd4f476ad6b0f295ef1239147c0c3924cb80f7","_id":"chai-immutable@1.5.0","_shasum":"4c211c18cb0fa8bdd6e79f24028a6b3031b85248","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"4c211c18cb0fa8bdd6e79f24028a6b3031b85248","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.5.0.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}]},"1.5.1":{"name":"chai-immutable","version":"1.5.1","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run test-mocha; npm run test-phantomjs; npm run check-style","test-mocha":"mocha","test-phantomjs":"mocha-phantomjs test/index.html","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":">= 2.0.0 < 4"},"devDependencies":{"chai":"^3.2.0","coveralls":"^2.11.2","immutable":"^3.7.3","istanbul":"^0.4.0","jscs":"^2.1.1","mocha":"^2.2.5","mocha-phantomjs":"^4.0.1"},"gitHead":"91d3a49b254689bbc9936cf3bdf1085debdeb9bf","_id":"chai-immutable@1.5.1","_shasum":"c6f10127ca0489d0e789238b92a7adaea09a1355","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.1","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"c6f10127ca0489d0e789238b92a7adaea09a1355","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.5.1.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}]},"1.5.2":{"name":"chai-immutable","version":"1.5.2","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run test-mocha; npm run test-phantomjs; npm run check-style","test-mocha":"mocha","test-phantomjs":"mocha-phantomjs test/index.html","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":">= 2.0.0 < 4"},"devDependencies":{"chai":"^3.4.0","coveralls":"^2.11.4","immutable":"^3.7.5","istanbul":"^0.4.0","jscs":"^2.5.0","mocha":"^2.3.3","mocha-phantomjs":"^4.0.1"},"gitHead":"0c68442164cd9a3c6494fb203d961c0a06c1ec21","_id":"chai-immutable@1.5.2","_shasum":"b69b2c8ca07f4b36fef1954ea54911fc7f779c58","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.2","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"b69b2c8ca07f4b36fef1954ea54911fc7f779c58","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.5.2.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}]},"1.5.3":{"name":"chai-immutable","version":"1.5.3","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run test-mocha; npm run test-phantomjs; npm run check-style","test-mocha":"mocha","test-phantomjs":"mocha-phantomjs test/index.html","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":">= 2.0.0 < 4"},"devDependencies":{"chai":"^3.4.0","coveralls":"^2.11.4","immutable":"^3.7.5","istanbul":"^0.4.0","jscs":"^2.5.0","mocha":"^2.3.3","mocha-phantomjs":"^4.0.1"},"gitHead":"6a9c9ed5d0c1f6bee65c24a9d426abf4125a7bbd","_id":"chai-immutable@1.5.3","_shasum":"d88a7843b923e33688fd57de2587dd853e0f274b","_from":".","_npmVersion":"2.14.7","_nodeVersion":"4.2.2","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"d88a7843b923e33688fd57de2587dd853e0f274b","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.5.3.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}]},"1.5.4":{"name":"chai-immutable","version":"1.5.4","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run test-mocha; npm run test-phantomjs; npm run check-style","test-mocha":"mocha","test-phantomjs":"mocha-phantomjs test/index.html","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":">= 2.0.0 < 4"},"devDependencies":{"chai":"^3.4.0","coveralls":"^2.11.8","immutable":"^3.7.5","istanbul":"^0.4.2","jscs":"^2.5.0","mocha":"^2.4.5","mocha-phantomjs":"^4.0.2"},"gitHead":"a7cfc90eea4a34023edc08d665138ae879dc3695","_id":"chai-immutable@1.5.4","_shasum":"7f695452b1a6f135e488d56f4f9b16125965cf81","_from":".","_npmVersion":"2.14.12","_nodeVersion":"4.2.6","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"7f695452b1a6f135e488d56f4f9b16125965cf81","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.5.4.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/chai-immutable-1.5.4.tgz_1458862438052_0.9728610638994724"}},"1.6.0":{"name":"chai-immutable","version":"1.6.0","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run test-mocha; npm run test-phantomjs; npm run check-style","test-mocha":"mocha","test-phantomjs":"echo 'mocha-phantomjs is temporarily disabled.' # mocha-phantomjs test/index.html","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":">= 2.0.0 < 4"},"devDependencies":{"chai":"^3.4.0","coveralls":"^2.11.9","immutable":"^3.7.5","istanbul":"^0.4.3","jscs":"^2.5.0","mocha":"^2.4.5"},"gitHead":"954d3478530b65743c4180197a178ebaffa232a1","_id":"chai-immutable@1.6.0","_shasum":"9ec00bdd67948b13b20fcbb89cbf4af2ce6f9247","_from":".","_npmVersion":"2.15.5","_nodeVersion":"4.4.5","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"9ec00bdd67948b13b20fcbb89cbf4af2ce6f9247","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-1.6.0.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/chai-immutable-1.6.0.tgz_1465620232842_0.34194417716935277"}},"2.0.0-alpha.1":{"name":"chai-immutable","version":"2.0.0-alpha.1","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","publishConfig":{"tag":"next"},"main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"check-style":"jscs chai-immutable.js test/test.js","test":"npm run test-mocha; npm run test-phantomjs; npm run test-readme; npm run check-style","test-readme":"mocha --compilers md:fulky/mocha-md-compiler README.md","test-mocha":"mocha","test-phantomjs":"mocha-phantomjs test/index.html","coverage":"istanbul cover _mocha","coveralls":"npm run coverage && cat ./coverage/lcov.info | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":"^4.0.0"},"devDependencies":{"chai":"^4.0.0","coveralls":"^2.11.9","fulky":"^0.1.0","immutable":"^3.7.5","istanbul":"^0.4.3","jscs":"^2.5.0","mocha":"^2.4.5","mocha-phantomjs":"^4.1.0"},"gitHead":"db28dda76cc0bf33aa94672adfaf56b03ce6f075","_id":"chai-immutable@2.0.0-alpha.1","_shasum":"0e0f3ae9cc09208188f94392c5fd6ecbd4e65d75","_from":".","_npmVersion":"2.15.11","_nodeVersion":"4.8.4","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"shasum":"0e0f3ae9cc09208188f94392c5fd6ecbd4e65d75","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-2.0.0-alpha.1.tgz"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/chai-immutable-2.0.0-alpha.1.tgz_1501136930731_0.8085173168219626"}},"2.0.0-alpha.2":{"name":"chai-immutable","version":"2.0.0-alpha.2","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"lint":"eslint --ignore-path .gitignore . --report-unused-disable-directives","test":"npm run test-mocha; npm run test-readme; npm run lint","test-readme":"mocha --compilers md:fulky/md-compiler README.md","test-mocha":"nyc mocha","coveralls":"nyc report --reporter=text-lcov | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","engines":{"node":">=6"},"bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":"^4.0.0","immutable":"^3.0.0"},"devDependencies":{"chai":"4.1.2","coveralls":"3.0.1","eslint":"4.19.1","eslint-plugin-chai-expect":"1.1.1","eslint-plugin-chai-friendly":"0.4.1","eslint-plugin-mocha":"5.0.0","fulky":"0.2.0","immutable":"3.8.2","mocha":"5.2.0","nyc":"11.8.0"},"gitHead":"c91bcc27b7087c15eb2e82fcc74286f8c4bcc9a6","readme":"[![npm Version](https://img.shields.io/npm/v/chai-immutable.svg)](https://npmjs.org/package/chai-immutable)\n[![License](https://img.shields.io/npm/l/chai-immutable.svg)](LICENSE)\n[![Build Status](https://travis-ci.org/astorije/chai-immutable.svg?branch=master)](https://travis-ci.org/astorije/chai-immutable)\n[![Build Status](https://ci.appveyor.com/api/projects/status/407ts84pq7wd4kt9/branch/master?svg=true)](https://ci.appveyor.com/project/astorije/chai-immutable/branch/master)\n[![Coverage Status](https://coveralls.io/repos/astorije/chai-immutable/badge.svg)](https://coveralls.io/r/astorije/chai-immutable)\n[![devDependencies Status](https://david-dm.org/astorije/chai-immutable/dev-status.svg)](https://david-dm.org/astorije/chai-immutable?type=dev)\n[![peerDependencies Status](https://david-dm.org/astorije/chai-immutable/peer-status.svg)](https://david-dm.org/astorije/chai-immutable?type=peer)\n\n# Chai Immutable\n\nThis plugin provides a set of [Chai](http://chaijs.com/) assertions for [Facebook's Immutable library for JavaScript collections](http://facebook.github.io/immutable-js/).\n\n<!-- fulky:globals\nvar chai = require('chai');\nvar assert = chai.assert;\nvar expect = chai.expect;\n\nvar Immutable = require('immutable');\nvar List = Immutable.List;\nvar Map = Immutable.Map;\nvar Set = Immutable.Set;\nvar Stack = Immutable.Stack;\n\nchai.use(require('./chai-immutable'));\n-->\n\n## Installation\n\n### Node.js\n\nInstall via [npm](http://npmjs.org):\n\n```bash\nnpm install chai-immutable\n```\n\n⚠️ To use `chai-immutable` with Chai v4, you need to use `npm install chai-immutable@next` instead, until I am done with the v2 release of this plugin. I apologize for the inconvenience in the meantime.\n\nYou can then use this plugin as any other Chai plugins:\n\n<!-- fulky:skip-test -->\n```js\nvar chai = require('chai');\nvar chaiImmutable = require('chai-immutable');\n\nchai.use(chaiImmutable);\n```\n\n### In the browser\n\nInclude this plugin after including Chai and Immutable. It will automatically\nplug in to Chai and be ready for use:\n\n```html\n<script src=\"chai-immutable.js\"></script>\n```\n\n### Using `chai-immutable` with other plugins\n\nIf you are using this plugin with\n[`chai-as-promised`](https://github.com/domenic/chai-as-promised/) or\n[`dirty-chai`](https://github.com/prodatakey/dirty-chai), note that\n`chai-immutable` must be loaded **before** any of them. For example:\n\n<!-- fulky:skip-test -->\n```js\nvar chai = require('chai');\nvar chaiAsPromised = require('chai-as-promised');\nvar chaiImmutable = require('chai-immutable');\nvar dirtyChai = require('dirty-chai');\nvar expect = chai.expect;\n\nchai.use(chaiImmutable);\nchai.use(dirtyChai);\nchai.use(chaiAsPromised);\n\nvar List = require('immutable').List;\n\n/* ... */\nreturn expect(List.of(1, 2, 3)).to.eventually.have.size(3);\nexpect(true).to.be.true();\n```\n\n## BDD API Reference\n\n### .empty\n\nAsserts that the immutable collection is empty.\n\n```js\nexpect(List()).to.be.empty;\nexpect(List.of(1, 2, 3)).to.not.be.empty;\n```\n\n### .equal(collection)\n\n- **@param** *{ Collection }* collection\n\nAsserts that the values of the target are equivalent to the values of\n`collection`. Aliases of Chai's original `equal` method are also supported.\n\n```js\nvar a = List.of(1, 2, 3);\nvar b = List.of(1, 2, 3);\nexpect(a).to.equal(b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\nAlso, note that `deep.equal` and `eql` are synonyms of `equal` when\ntested against immutable data structures, therefore they are aliases to\n`equal`.\n\n### .include(value)\n\n- **@param** *{ Mixed }* val\n\nThe `include` and `contain` assertions can be used as either property\nbased language chains or as methods to assert the inclusion of a value\nin an immutable collection. When used as language chains, they toggle the\n`contains` flag for the `keys` assertion.\n\nNote that `deep.include` behaves exactly like `include` in the context of\nimmutable data structures.\n\n```js\nexpect(new List([1, 2, 3])).to.include(2);\nexpect(new List([1, 2, 3])).to.deep.include(2);\nexpect(new Map({ foo: 'bar', hello: 'world' })).to.include.keys('foo');\n```\n\n### .keys(key1[, key2[, ...]])\n\n- **@param** *{ String... | Array | Object | Collection }* key*N*\n\nAsserts that the target collection has the given keys.\n\nWhen the target is an object or array, keys can be provided as one or more\nstring arguments, a single array argument, a single object argument, or an\nimmutable collection. In the last 2 cases, only the keys in the given\nobject/collection matter; the values are ignored.\n\n```js\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys('foo', 'bar');\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new List(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Set(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Stack(['bar', 'foo']));\nexpect(new List(['x', 'y'])).to.have.all.keys(0, 1);\n\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(['foo', 'bar']);\nexpect(new List(['x', 'y'])).to.have.all.keys([0, 1]);\n\n// Values in the passed object are ignored:\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys({ bar: 6, foo: 7 });\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Map({ bar: 6, foo: 7 }));\nexpect(new List(['x', 'y'])).to.have.all.keys({ 0: 4, 1: 5 });\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nBy default, the target must have all of the given keys and no more. Add\n`.any` earlier in the chain to only require that the target have at least\none of the given keys. Also, add `.not` earlier in the chain to negate\n`.keys`. It's often best to add `.any` when negating `.keys`, and to use\n`.all` when asserting `.keys` without negation.\n\nWhen negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\nexactly what's expected of the output, whereas `.not.all.keys` creates\nuncertain expectations.\n\n```js\n// Recommended; asserts that target doesn't have any of the given keys\nexpect(new Map({a: 1, b: 2})).to.not.have.any.keys('c', 'd');\n\n// Not recommended; asserts that target doesn't have all of the given\n// keys but may or may not have some of them\nexpect(new Map({a: 1, b: 2})).to.not.have.all.keys('c', 'd');\n```\n\nWhen asserting `.keys` without negation, `.all` is preferred because\n`.all.keys` asserts exactly what's expected of the output, whereas\n`.any.keys` creates uncertain expectations.\n\n```js\n// Recommended; asserts that target has all the given keys\nexpect(new Map({a: 1, b: 2})).to.have.all.keys('a', 'b');\n\n// Not recommended; asserts that target has at least one of the given\n// keys but may or may not have more of them\nexpect(new Map({a: 1, b: 2})).to.have.any.keys('a', 'b');\n```\n\nNote that `.all` is used by default when neither `.all` nor `.any` appear\nearlier in the chain. However, it's often best to add `.all` anyway because\nit improves readability.\n\n```js\n// Both assertions are identical\nexpect(new Map({a: 1, b: 2})).to.have.all.keys('a', 'b'); // Recommended\nexpect(new Map({a: 1, b: 2})).to.have.keys('a', 'b'); // Not recommended\n```\n\nAdd `.include` earlier in the chain to require that the target's keys be a\nsuperset of the expected keys, rather than identical sets.\n\n```js\n// Target object's keys are a superset of ['a', 'b'] but not identical\nexpect(new Map({a: 1, b: 2, c: 3})).to.include.all.keys('a', 'b');\nexpect(new Map({a: 1, b: 2, c: 3})).to.not.have.all.keys('a', 'b');\n```\n\nHowever, if `.any` and `.include` are combined, only the `.any` takes\neffect. The `.include` is ignored in this case.\n\n```js\n// Both assertions are identical\nexpect(new Map({a: 1})).to.have.any.keys('a', 'b');\nexpect(new Map({a: 1})).to.include.any.keys('a', 'b');\n```\n\nThe alias `.key` can be used interchangeably with `.keys`.\n\n```js\nexpect(new Map({ foo: 1 })).to.have.key('foo');\n```\n\n### .property(path[, val])\n\n- **@param** *{ String | Array | Iterable }* path\n- **@param** *{ Mixed }* val (optional)\n\nAsserts that the target has a property with the given `path`.\n\n```js\nexpect(new Map({a: 1})).to.have.property('a');\n```\n\nWhen `val` is provided, `.property` also asserts that the property's value\nis equal to the given `val`. `val` can be an immutable collection.\n\n```js\nexpect(new Map({a: 1})).to.have.property('a', 1);\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nAdd `.nested` earlier in the chain to enable dot- and bracket-notation when\nreferencing nested properties. An immutable `List` can also be used as the\nstarting point of a `nested.property`.\n\n```js\nexpect(Immutable.fromJS({a: {b: ['x', 'y']}})).to.have.nested.property('a.b[1]');\nexpect(Immutable.fromJS({a: {b: ['x', 'y']}})).to.have.nested.property('a.b[1]', 'y');\nexpect(Immutable.fromJS({a: {b: ['x', 'y']}})).to.have.nested.property(['a', 'b', 1], 'y');\nexpect(Immutable.fromJS({a: {b: ['x', 'y']}})).to.have.nested.property(new List(['a', 'b', 1]), 'y');\n```\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n```js\nexpect(Immutable.fromJS({'.a': {'[b]': 'x'}})).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n```\n\nAdd `.not` earlier in the chain to negate `.property`.\n\n```js\nexpect(new Map({a: 1})).to.not.have.property('b');\n```\n\nHowever, it's dangerous to negate `.property` when providing `val`. The\nproblem is that it creates uncertain expectations by asserting that the\ntarget either doesn't have a property at the given `path`, or that it\ndoes have a property at the given key `path` but its value isn't equal to\nthe given `val`. It's often best to identify the exact output that's\nexpected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn't expected to have a property at the given\n`path`, it's often best to assert exactly that.\n\n```js\nexpect(new Map({b: 2})).to.not.have.property('a'); // Recommended\nexpect(new Map({b: 2})).to.not.have.property('a', 1); // Not recommended\n```\n\nWhen the target is expected to have a property at the given key `path`,\nit's often best to assert that the property has its expected value, rather\nthan asserting that it doesn't have one of many unexpected values.\n\n```js\nexpect(new Map({a: 3})).to.have.property('a', 3); // Recommended\nexpect(new Map({a: 3})).to.not.have.property('a', 1); // Not recommended\n```\n\n`.property` changes the target of any assertions that follow in the chain\nto be the value of the property from the original target object.\n\n```js\nexpect(new Map({a: 1})).to.have.property('a').that.is.a('number');\n```\n\n### .size(value)\n\n- **@param** *{ Number }* size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size(3);\n```\n\nIt can also be used as a chain precursor to a value comparison for the\n`size` property.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size.least(3);\nexpect(List.of(1, 2, 3)).to.have.size.most(3);\nexpect(List.of(1, 2, 3)).to.have.size.above(2);\nexpect(List.of(1, 2, 3)).to.have.size.below(4);\nexpect(List.of(1, 2, 3)).to.have.size.within(2,4);\n```\n\nSimilarly to `length`/`lengthOf`, `sizeOf` is an alias of `size`:\n\n```js\nexpect(List.of(1, 2, 3)).to.have.sizeOf(3);\n```\n\n## TDD API Reference\n\n### .equal(actual, expected)\n\n- **@param** *{ Collection }* actual\n- **@param** *{ Collection }* expected\n\nAsserts that the values of `actual` are equivalent to the values of\n`expected`. Note that `.strictEqual()` and `.deepEqual()` assert\nexactly like `.equal()` in the context of Immutable data structures.\n\n```js\nvar a = List.of(1, 2, 3);\nvar b = List.of(1, 2, 3);\nassert.equal(a, b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`, `.strictEqual()` or `.deepEqual()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\n### .notEqual(actual, expected)\n\n- **@param** *{ Collection }* actual\n- **@param** *{ Collection }* expected\n\nAsserts that the values of `actual` are not equivalent to the values of\n`expected`. Note that `.notStrictEqual()` and `.notDeepEqual()` assert\nexactly like `.notEqual()` in the context of Immutable data structures.\n\n```js\nvar a = List.of(1, 2, 3);\nvar b = List.of(4, 5, 6);\nassert.notEqual(a, b);\n```\n\n### .sizeOf(collection, length)\n\n- **@param** *{ Collection }* collection\n- **@param** *{ Number }* size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nassert.sizeOf(List.of(1, 2, 3), 3);\nassert.sizeOf(new List(), 0);\n```\n","readmeFilename":"README.md","_id":"chai-immutable@2.0.0-alpha.2","_npmVersion":"5.6.0","_nodeVersion":"8.11.2","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"integrity":"sha512-62y3J1XSgUHiAJqVxnXAqGhn5i25sU+lp+hWI9EVYNPf9PFCF0ER3mV3hR/uQCGMJmhFVTPRVDk0RJ4Rfq3shg==","shasum":"a598d9a9fc51d79d2e8f0cedde1daf261cf1763a","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-2.0.0-alpha.2.tgz","fileCount":12,"unpackedSize":101889,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbAZ5hCRA9TVsSAnZWagAAZH8P/3YqdFAsc4gnnwtijLli\nh22eCA1mu/zmSX3X+Yd7Pa4OldjYL/iP+yKhYTpPA+DS/vPRcwyqWt6D9MN5\nAul0Fa1LTaP1+biAZQI+bljDxGlPwHFahZIFaM1sl9l6eb1rDM6eImSZyARt\nwvoW3UNzrT6TndClkvqzsIVpqulvtR513nxxCdZjgtPXVNRxFyYBaBJJpw6o\nERCxVrq6bQ5iidlx3OwWRWoNrUkRz9fTC5kXscNDn3LizkNI2wSJKSC2/1pu\n1WQf22oROEQ3179e9Q8KIiwTfs8XNqa8uSFyMWWMmsgt0yxRb6Xp6HsOcqCD\ntE2KuHm7a/HreDo00GmEj0C1dhoJb5DZIDxzhphZpVd82JTJeHlarUWumPx8\nEBaimkx9z0y2eNDWQjUiYmb/sB10L0JOLVzjoRYu6Upc6YcEanhWtXQ2LFtx\nMd+6yQD2xXf3FL9qVELf67vPlzYjxBvXLYYRU15eGdv/GiZf1INJlyN3v/YG\nch6StoDpqO4Jcqq2miOkNJfEDERAAo2IdzsT1hDxY5zBonveuoBeRZNmMLoX\nh1qo+3tTdiySAYYNLdE4QDxF4E9uxYg8hFgRt7doVN8QpXGD5SGJx9FxortJ\nRBwtkvLiBYO2KFgaLLthBu7DifP/UgM72vtizkM1I9uOXnFJJGGQkEnsEoNC\njrA7\r\n=1uZG\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/chai-immutable_2.0.0-alpha.2_1526832735316_0.09183840380572339"},"_hasShrinkwrap":false},"2.0.0-rc.1":{"name":"chai-immutable","version":"2.0.0-rc.1","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","directories":{"test":"test"},"scripts":{"lint":"eslint --ignore-path .gitignore . --report-unused-disable-directives","test":"run-s --continue-on-error test:* lint","test:readme":"mocha --compilers md:fulky/md-compiler README.md","test:mocha":"nyc mocha","coveralls":"nyc report --reporter=text-lcov | coveralls"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","engines":{"node":">=6"},"bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":"^4.0.0","immutable":"^3.0.0"},"devDependencies":{"chai":"4.1.2","coveralls":"3.0.1","eslint":"4.19.1","eslint-plugin-chai-expect":"1.1.1","eslint-plugin-chai-friendly":"0.4.1","eslint-plugin-mocha":"5.0.0","fulky":"0.2.0","immutable":"3.8.2","mocha":"5.2.0","npm-run-all":"4.1.3","nyc":"11.8.0"},"gitHead":"65e8544837e61b10f8eba3fd862ead519be4a23a","readme":"[![npm Version](https://img.shields.io/npm/v/chai-immutable.svg)](https://npmjs.org/package/chai-immutable)\n[![License](https://img.shields.io/npm/l/chai-immutable.svg)](LICENSE)\n[![Build Status](https://travis-ci.org/astorije/chai-immutable.svg?branch=master)](https://travis-ci.org/astorije/chai-immutable)\n[![Build Status](https://ci.appveyor.com/api/projects/status/407ts84pq7wd4kt9/branch/master?svg=true)](https://ci.appveyor.com/project/astorije/chai-immutable/branch/master)\n[![Coverage Status](https://coveralls.io/repos/astorije/chai-immutable/badge.svg)](https://coveralls.io/r/astorije/chai-immutable)\n[![devDependencies Status](https://david-dm.org/astorije/chai-immutable/dev-status.svg)](https://david-dm.org/astorije/chai-immutable?type=dev)\n[![peerDependencies Status](https://david-dm.org/astorije/chai-immutable/peer-status.svg)](https://david-dm.org/astorije/chai-immutable?type=peer)\n\n# Chai Immutable\n\nThis plugin provides a set of [Chai](http://chaijs.com/) assertions for [Facebook's Immutable library for JavaScript collections](http://facebook.github.io/immutable-js/).\n\n<!-- fulky:globals\nconst chai = require('chai');\nconst { assert, expect } = chai;\n\nconst Immutable = require('immutable');\nconst {\n  List,\n  Map,\n  Set,\n  Stack,\n} = Immutable;\n\nchai.use(require('./chai-immutable'));\n-->\n\n## Installation\n\n### Node.js\n\nInstall via [npm](http://npmjs.org) or [yarn](https://yarnpkg.com/):\n\n```bash\nnpm install --save-dev chai-immutable\nyarn add --dev chai-immutable\n```\n\n⚠️ **To use `chai-immutable` with Chai v4, you need to use\n`npm install --save-dev chai-immutable@next` (or\n`yarn add --dev chai-immutable@next`) instead, until I am done with the v2\nrelease of this plugin. I apologize for the inconvenience in the meantime.**\n\nYou can then use this plugin as any other Chai plugins:\n\n<!-- fulky:skip-test -->\n```js\nconst chai = require('chai');\nconst chaiImmutable = require('chai-immutable');\n\nchai.use(chaiImmutable);\n```\n\n### ES6 syntax (needs Babel transpiling)\n\n<!-- fulky:skip-test -->\n```js\nimport chai from 'chai';\nimport chaiImmutable from 'chai-immutable';\n\nchai.use(chaiImmutable);\n```\n\n### In the browser\n\nInclude this plugin after including Chai and Immutable. It will automatically\nplug in to Chai and be ready for use:\n\n```html\n<script src=\"chai-immutable.js\"></script>\n```\n\n### Using `chai-immutable` with other plugins\n\nIf you are using this plugin with\n[`chai-as-promised`](https://github.com/domenic/chai-as-promised/) or\n[`dirty-chai`](https://github.com/prodatakey/dirty-chai), note that\n`chai-immutable` must be loaded **before** any of them. For example:\n\n<!-- fulky:skip-test -->\n```js\nconst chai = require('chai');\nconst chaiAsPromised = require('chai-as-promised');\nconst chaiImmutable = require('chai-immutable');\nconst dirtyChai = require('dirty-chai');\nconst { expect } = chai;\n\nchai.use(chaiImmutable);\nchai.use(chaiAsPromised);\nchai.use(dirtyChai);\n\nconst { List } = require('immutable');\n\n/* ... */\n\nexpect(Promise.resolve(List.of(1, 2, 3))).to.eventually.have.size(3);\nexpect(true).to.be.true();\n```\n\n## BDD API Reference\n\n### .empty\n\nAsserts that the immutable collection is empty.\n\n```js\nexpect(List()).to.be.empty;\nexpect(List.of(1, 2, 3)).to.not.be.empty;\n```\n\n### .equal(collection)\n\n- **@param** *{ Collection }* collection\n\nAsserts that the values of the target are equivalent to the values of\n`collection`. Aliases of Chai's original `equal` method are also supported.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(1, 2, 3);\nexpect(a).to.equal(b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\nAlso, note that `deep.equal` and `eql` are synonyms of `equal` when\ntested against immutable data structures, therefore they are aliases to\n`equal`.\n\n### .include(value)\n\n- **@param** *{ Mixed }* val\n\nThe `include` and `contain` assertions can be used as either property\nbased language chains or as methods to assert the inclusion of a value\nin an immutable collection. When used as language chains, they toggle the\n`contains` flag for the `keys` assertion.\n\nNote that `deep.include` behaves exactly like `include` in the context of\nimmutable data structures.\n\n```js\nexpect(new List([1, 2, 3])).to.include(2);\nexpect(new List([1, 2, 3])).to.deep.include(2);\nexpect(new Map({ foo: 'bar', hello: 'world' })).to.include.keys('foo');\n```\n\n### .keys(key1[, key2[, ...]])\n\n- **@param** *{ String... | Array | Object | Collection }* key*N*\n\nAsserts that the target collection has the given keys.\n\nWhen the target is an object or array, keys can be provided as one or more\nstring arguments, a single array argument, a single object argument, or an\nimmutable collection. In the last 2 cases, only the keys in the given\nobject/collection matter; the values are ignored.\n\n```js\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys('foo', 'bar');\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new List(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Set(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Stack(['bar', 'foo']));\nexpect(new List(['x', 'y'])).to.have.all.keys(0, 1);\n\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(['foo', 'bar']);\nexpect(new List(['x', 'y'])).to.have.all.keys([0, 1]);\n\n// Values in the passed object are ignored:\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys({ bar: 6, foo: 7 });\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Map({ bar: 6, foo: 7 }));\nexpect(new List(['x', 'y'])).to.have.all.keys({ 0: 4, 1: 5 });\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nBy default, the target must have all of the given keys and no more. Add\n`.any` earlier in the chain to only require that the target have at least\none of the given keys. Also, add `.not` earlier in the chain to negate\n`.keys`. It's often best to add `.any` when negating `.keys`, and to use\n`.all` when asserting `.keys` without negation.\n\nWhen negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\nexactly what's expected of the output, whereas `.not.all.keys` creates\nuncertain expectations.\n\n```js\n// Recommended; asserts that target doesn't have any of the given keys\nexpect(new Map({a: 1, b: 2})).to.not.have.any.keys('c', 'd');\n\n// Not recommended; asserts that target doesn't have all of the given\n// keys but may or may not have some of them\nexpect(new Map({a: 1, b: 2})).to.not.have.all.keys('c', 'd');\n```\n\nWhen asserting `.keys` without negation, `.all` is preferred because\n`.all.keys` asserts exactly what's expected of the output, whereas\n`.any.keys` creates uncertain expectations.\n\n```js\n// Recommended; asserts that target has all the given keys\nexpect(new Map({a: 1, b: 2})).to.have.all.keys('a', 'b');\n\n// Not recommended; asserts that target has at least one of the given\n// keys but may or may not have more of them\nexpect(new Map({a: 1, b: 2})).to.have.any.keys('a', 'b');\n```\n\nNote that `.all` is used by default when neither `.all` nor `.any` appear\nearlier in the chain. However, it's often best to add `.all` anyway because\nit improves readability.\n\n```js\n// Both assertions are identical\nexpect(new Map({a: 1, b: 2})).to.have.all.keys('a', 'b'); // Recommended\nexpect(new Map({a: 1, b: 2})).to.have.keys('a', 'b'); // Not recommended\n```\n\nAdd `.include` earlier in the chain to require that the target's keys be a\nsuperset of the expected keys, rather than identical sets.\n\n```js\n// Target object's keys are a superset of ['a', 'b'] but not identical\nexpect(new Map({a: 1, b: 2, c: 3})).to.include.all.keys('a', 'b');\nexpect(new Map({a: 1, b: 2, c: 3})).to.not.have.all.keys('a', 'b');\n```\n\nHowever, if `.any` and `.include` are combined, only the `.any` takes\neffect. The `.include` is ignored in this case.\n\n```js\n// Both assertions are identical\nexpect(new Map({a: 1})).to.have.any.keys('a', 'b');\nexpect(new Map({a: 1})).to.include.any.keys('a', 'b');\n```\n\nThe alias `.key` can be used interchangeably with `.keys`.\n\n```js\nexpect(new Map({ foo: 1 })).to.have.key('foo');\n```\n\n### .property(path[, val])\n\n- **@param** *{ String | Array | Iterable }* path\n- **@param** *{ Mixed }* val (optional)\n\nAsserts that the target has a property with the given `path`.\n\n```js\nexpect(new Map({a: 1})).to.have.property('a');\n```\n\nWhen `val` is provided, `.property` also asserts that the property's value\nis equal to the given `val`. `val` can be an immutable collection.\n\n```js\nexpect(new Map({a: 1})).to.have.property('a', 1);\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nAdd `.nested` earlier in the chain to enable dot- and bracket-notation when\nreferencing nested properties. An immutable `List` can also be used as the\nstarting point of a `nested.property`.\n\n```js\nexpect(Immutable.fromJS({a: {b: ['x', 'y']}})).to.have.nested.property('a.b[1]');\nexpect(Immutable.fromJS({a: {b: ['x', 'y']}})).to.have.nested.property('a.b[1]', 'y');\nexpect(Immutable.fromJS({a: {b: ['x', 'y']}})).to.have.nested.property(['a', 'b', 1], 'y');\nexpect(Immutable.fromJS({a: {b: ['x', 'y']}})).to.have.nested.property(new List(['a', 'b', 1]), 'y');\n```\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n```js\nexpect(Immutable.fromJS({'.a': {'[b]': 'x'}})).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n```\n\nAdd `.not` earlier in the chain to negate `.property`.\n\n```js\nexpect(new Map({a: 1})).to.not.have.property('b');\n```\n\nHowever, it's dangerous to negate `.property` when providing `val`. The\nproblem is that it creates uncertain expectations by asserting that the\ntarget either doesn't have a property at the given `path`, or that it\ndoes have a property at the given key `path` but its value isn't equal to\nthe given `val`. It's often best to identify the exact output that's\nexpected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn't expected to have a property at the given\n`path`, it's often best to assert exactly that.\n\n```js\nexpect(new Map({b: 2})).to.not.have.property('a'); // Recommended\nexpect(new Map({b: 2})).to.not.have.property('a', 1); // Not recommended\n```\n\nWhen the target is expected to have a property at the given key `path`,\nit's often best to assert that the property has its expected value, rather\nthan asserting that it doesn't have one of many unexpected values.\n\n```js\nexpect(new Map({a: 3})).to.have.property('a', 3); // Recommended\nexpect(new Map({a: 3})).to.not.have.property('a', 1); // Not recommended\n```\n\n`.property` changes the target of any assertions that follow in the chain\nto be the value of the property from the original target object.\n\n```js\nexpect(new Map({a: 1})).to.have.property('a').that.is.a('number');\n```\n\n### .size(value)\n\n- **@param** *{ Number }* size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size(3);\n```\n\nIt can also be used as a chain precursor to a value comparison for the\n`size` property.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size.least(3);\nexpect(List.of(1, 2, 3)).to.have.size.most(3);\nexpect(List.of(1, 2, 3)).to.have.size.above(2);\nexpect(List.of(1, 2, 3)).to.have.size.below(4);\nexpect(List.of(1, 2, 3)).to.have.size.within(2,4);\n```\n\nSimilarly to `length`/`lengthOf`, `sizeOf` is an alias of `size`:\n\n```js\nexpect(List.of(1, 2, 3)).to.have.sizeOf(3);\n```\n\n## TDD API Reference\n\n### .equal(actual, expected)\n\n- **@param** *{ Collection }* actual\n- **@param** *{ Collection }* expected\n\nAsserts that the values of `actual` are equivalent to the values of\n`expected`. Note that `.strictEqual()` and `.deepEqual()` assert\nexactly like `.equal()` in the context of Immutable data structures.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(1, 2, 3);\nassert.equal(a, b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`, `.strictEqual()` or `.deepEqual()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\n### .notEqual(actual, expected)\n\n- **@param** *{ Collection }* actual\n- **@param** *{ Collection }* expected\n\nAsserts that the values of `actual` are not equivalent to the values of\n`expected`. Note that `.notStrictEqual()` and `.notDeepEqual()` assert\nexactly like `.notEqual()` in the context of Immutable data structures.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(4, 5, 6);\nassert.notEqual(a, b);\n```\n\n### .sizeOf(collection, length)\n\n- **@param** *{ Collection }* collection\n- **@param** *{ Number }* size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nassert.sizeOf(List.of(1, 2, 3), 3);\nassert.sizeOf(new List(), 0);\n```\n","readmeFilename":"README.md","_id":"chai-immutable@2.0.0-rc.1","_npmVersion":"5.6.0","_nodeVersion":"8.11.2","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"integrity":"sha512-x1ys9lUvmFfgIoS9ZqYxtMaX/KXbz3SStBQQYRmr1seRbN+8Y4GgYkcYSJYD8752j7gj3pDmiP/V6lcSWNfDbA==","shasum":"d4196e5dff1db159e7823b5e194cb7426de39175","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-2.0.0-rc.1.tgz","fileCount":12,"unpackedSize":103804,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbDNvmCRA9TVsSAnZWagAAQkgP/ivlEzqF03OUd/TQzQpA\n0qknM1gU33AglMZF5eH1c5eblSdyABT9KWMWT66L0TsYVkwkdlz9RDleUXXW\nNAxC5bbAEDNZg77niXPqjBRqCoC8vlN+JA1Towv52kTqYLK3LD7lqTyv5CpR\nw26AAmYb00MQS6cjgdok0t4A1GjVJ9XRauliuez4ylpckpZCADEDhgot+G2z\nV4W0y42/PUffxAGFQcOtr4am80F74yBvdSnzjz192stnmCBOYYneDpTLqGLy\nGkTuAfwn4o1uaDm9osp/eYAFYP0jRl+LkJv/HzD40i8ATux5BgNPTz7MS51H\nkAOHxh1MQOsFeqhRCC0LQFIzI8XorJrzJPqdVdkzCTKFmzn9/NBUv6Zh/v7M\nhMIVz0LhVRbzQErrb/qvNBZdYcnOEgNLKeDkTU01iRUai16tNvsWRET+nrgt\nJF4EzXjnyrO0VuOXgFkbZAWfuDLfridFIRkxVrlbxRY2Z3/AI9OjHM65hTLp\ni9lnJk2HNVNw5pF0aKNA7aYZ28VTDPdO5efzkAhTNtTRmK4TXlYPz+C5vsUi\niM9+lF5qJfBS6SYzuSwwwmnLRRsYA6QU73g6rKwq5OMvPwCOomEFY7aD7ZYV\nKPqGDazcq4OhWsK23qr9RiBa2vckGExCI+u4V4+ic7lSSe5vflQ9Bg+g0ZS7\nuyCk\r\n=9gwV\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/chai-immutable_2.0.0-rc.1_1527569382302_0.02285938312314606"},"_hasShrinkwrap":false},"2.0.0-rc.2":{"name":"chai-immutable","version":"2.0.0-rc.2","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","files":["chai-immutable.js"],"scripts":{"format":"run-s -c \"lint:eslint --fix\" \"lint:prettier --write\"","lint:eslint":"eslint --ignore-path .gitignore . --report-unused-disable-directives","lint:prettier":"prettier --list-different \"**/*.{js,md}\"","test":"run-s -c test:* lint:* eslint-check:*","test:readme":"mocha --compilers md:fulky/md-compiler README.md","test:mocha":"nyc mocha","coveralls":"nyc report --reporter=text-lcov | coveralls","eslint-check:main":"eslint --print-config .eslintrc.yml | eslint-config-prettier-check","eslint-check:test":"eslint --print-config test/.eslintrc.yml | eslint-config-prettier-check"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","engines":{"node":">=6"},"bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":"^4.0.0","immutable":"^3.0.0"},"devDependencies":{"chai":"4.1.2","coveralls":"3.0.1","eslint":"4.19.1","eslint-config-prettier":"2.9.0","eslint-plugin-chai-expect":"1.1.1","eslint-plugin-chai-friendly":"0.4.1","eslint-plugin-mocha":"5.0.0","fulky":"0.2.0","immutable":"3.8.2","mocha":"5.2.0","npm-run-all":"4.1.3","nyc":"11.8.0","prettier":"1.13.0"},"gitHead":"68edb64298f59ea088a8da6137a04cb032ecec06","readme":"[![npm Version](https://img.shields.io/npm/v/chai-immutable.svg)](https://npmjs.org/package/chai-immutable)\n[![License](https://img.shields.io/npm/l/chai-immutable.svg)](LICENSE)\n[![Build Status](https://travis-ci.org/astorije/chai-immutable.svg?branch=master)](https://travis-ci.org/astorije/chai-immutable)\n[![Build Status](https://ci.appveyor.com/api/projects/status/407ts84pq7wd4kt9/branch/master?svg=true)](https://ci.appveyor.com/project/astorije/chai-immutable/branch/master)\n[![Coverage Status](https://coveralls.io/repos/astorije/chai-immutable/badge.svg)](https://coveralls.io/r/astorije/chai-immutable)\n[![devDependencies Status](https://david-dm.org/astorije/chai-immutable/dev-status.svg)](https://david-dm.org/astorije/chai-immutable?type=dev)\n[![peerDependencies Status](https://david-dm.org/astorije/chai-immutable/peer-status.svg)](https://david-dm.org/astorije/chai-immutable?type=peer)\n\n# Chai Immutable\n\nThis plugin provides a set of [Chai](http://chaijs.com/) assertions for [Facebook's Immutable library for JavaScript collections](http://facebook.github.io/immutable-js/).\n\n<!-- fulky:globals\nconst chai = require('chai');\nconst { assert, expect } = chai;\n\nconst Immutable = require('immutable');\nconst {\n  List,\n  Map,\n  Set,\n  Stack,\n} = Immutable;\n\nchai.use(require('./chai-immutable'));\n-->\n\n## Installation\n\n### Node.js\n\nInstall via [npm](http://npmjs.org) or [yarn](https://yarnpkg.com/):\n\n```bash\nnpm install --save-dev chai-immutable\nyarn add --dev chai-immutable\n```\n\n⚠️ **To use `chai-immutable` with Chai v4, you need to use\n`npm install --save-dev chai-immutable@next` (or\n`yarn add --dev chai-immutable@next`) instead, until I am done with the v2\nrelease of this plugin. I apologize for the inconvenience in the meantime.**\n\nYou can then use this plugin as any other Chai plugins:\n\n<!-- fulky:skip-test -->\n\n```js\nconst chai = require('chai');\nconst chaiImmutable = require('chai-immutable');\n\nchai.use(chaiImmutable);\n```\n\n### ES6 syntax (needs Babel transpiling)\n\n<!-- fulky:skip-test -->\n\n```js\nimport chai from 'chai';\nimport chaiImmutable from 'chai-immutable';\n\nchai.use(chaiImmutable);\n```\n\n### In the browser\n\nInclude this plugin after including Chai and Immutable. It will automatically\nplug in to Chai and be ready for use:\n\n```html\n<script src=\"chai-immutable.js\"></script>\n```\n\n### Using `chai-immutable` with other plugins\n\nIf you are using this plugin with\n[`chai-as-promised`](https://github.com/domenic/chai-as-promised/) or\n[`dirty-chai`](https://github.com/prodatakey/dirty-chai), note that\n`chai-immutable` must be loaded **before** any of them. For example:\n\n<!-- fulky:skip-test -->\n\n```js\nconst chai = require('chai');\nconst chaiAsPromised = require('chai-as-promised');\nconst chaiImmutable = require('chai-immutable');\nconst dirtyChai = require('dirty-chai');\nconst { expect } = chai;\n\nchai.use(chaiImmutable);\nchai.use(chaiAsPromised);\nchai.use(dirtyChai);\n\nconst { List } = require('immutable');\n\n/* ... */\n\nexpect(Promise.resolve(List.of(1, 2, 3))).to.eventually.have.size(3);\nexpect(true).to.be.true();\n```\n\n## BDD API Reference\n\n### .empty\n\nAsserts that the immutable collection is empty.\n\n```js\nexpect(List()).to.be.empty;\nexpect(List.of(1, 2, 3)).to.not.be.empty;\n```\n\n### .equal(collection)\n\n- **@param** _{ Collection }_ collection\n\nAsserts that the values of the target are equivalent to the values of\n`collection`. Aliases of Chai's original `equal` method are also supported.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(1, 2, 3);\nexpect(a).to.equal(b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\nAlso, note that `deep.equal` and `eql` are synonyms of `equal` when\ntested against immutable data structures, therefore they are aliases to\n`equal`.\n\n### .include(value)\n\n- **@param** _{ Mixed }_ val\n\nThe `include` and `contain` assertions can be used as either property\nbased language chains or as methods to assert the inclusion of a value\nin an immutable collection. When used as language chains, they toggle the\n`contains` flag for the `keys` assertion.\n\nNote that `deep.include` behaves exactly like `include` in the context of\nimmutable data structures.\n\n```js\nexpect(new List([1, 2, 3])).to.include(2);\nexpect(new List([1, 2, 3])).to.deep.include(2);\nexpect(new Map({ foo: 'bar', hello: 'world' })).to.include.keys('foo');\n```\n\n### .keys(key1[, key2[, ...]])\n\n- **@param** _{ String... | Array | Object | Collection }_ key*N*\n\nAsserts that the target collection has the given keys.\n\nWhen the target is an object or array, keys can be provided as one or more\nstring arguments, a single array argument, a single object argument, or an\nimmutable collection. In the last 2 cases, only the keys in the given\nobject/collection matter; the values are ignored.\n\n```js\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys('foo', 'bar');\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new List(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Set(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Stack(['bar', 'foo']));\nexpect(new List(['x', 'y'])).to.have.all.keys(0, 1);\n\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(['foo', 'bar']);\nexpect(new List(['x', 'y'])).to.have.all.keys([0, 1]);\n\n// Values in the passed object are ignored:\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys({ bar: 6, foo: 7 });\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(\n  new Map({ bar: 6, foo: 7 })\n);\nexpect(new List(['x', 'y'])).to.have.all.keys({ 0: 4, 1: 5 });\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nBy default, the target must have all of the given keys and no more. Add\n`.any` earlier in the chain to only require that the target have at least\none of the given keys. Also, add `.not` earlier in the chain to negate\n`.keys`. It's often best to add `.any` when negating `.keys`, and to use\n`.all` when asserting `.keys` without negation.\n\nWhen negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\nexactly what's expected of the output, whereas `.not.all.keys` creates\nuncertain expectations.\n\n```js\n// Recommended; asserts that target doesn't have any of the given keys\nexpect(new Map({ a: 1, b: 2 })).to.not.have.any.keys('c', 'd');\n\n// Not recommended; asserts that target doesn't have all of the given\n// keys but may or may not have some of them\nexpect(new Map({ a: 1, b: 2 })).to.not.have.all.keys('c', 'd');\n```\n\nWhen asserting `.keys` without negation, `.all` is preferred because\n`.all.keys` asserts exactly what's expected of the output, whereas\n`.any.keys` creates uncertain expectations.\n\n```js\n// Recommended; asserts that target has all the given keys\nexpect(new Map({ a: 1, b: 2 })).to.have.all.keys('a', 'b');\n\n// Not recommended; asserts that target has at least one of the given\n// keys but may or may not have more of them\nexpect(new Map({ a: 1, b: 2 })).to.have.any.keys('a', 'b');\n```\n\nNote that `.all` is used by default when neither `.all` nor `.any` appear\nearlier in the chain. However, it's often best to add `.all` anyway because\nit improves readability.\n\n```js\n// Both assertions are identical\nexpect(new Map({ a: 1, b: 2 })).to.have.all.keys('a', 'b'); // Recommended\nexpect(new Map({ a: 1, b: 2 })).to.have.keys('a', 'b'); // Not recommended\n```\n\nAdd `.include` earlier in the chain to require that the target's keys be a\nsuperset of the expected keys, rather than identical sets.\n\n```js\n// Target object's keys are a superset of ['a', 'b'] but not identical\nexpect(new Map({ a: 1, b: 2, c: 3 })).to.include.all.keys('a', 'b');\nexpect(new Map({ a: 1, b: 2, c: 3 })).to.not.have.all.keys('a', 'b');\n```\n\nHowever, if `.any` and `.include` are combined, only the `.any` takes\neffect. The `.include` is ignored in this case.\n\n```js\n// Both assertions are identical\nexpect(new Map({ a: 1 })).to.have.any.keys('a', 'b');\nexpect(new Map({ a: 1 })).to.include.any.keys('a', 'b');\n```\n\nThe alias `.key` can be used interchangeably with `.keys`.\n\n```js\nexpect(new Map({ foo: 1 })).to.have.key('foo');\n```\n\n### .property(path[, val])\n\n- **@param** _{ String | Array | Iterable }_ path\n- **@param** _{ Mixed }_ val (optional)\n\nAsserts that the target has a property with the given `path`.\n\n```js\nexpect(new Map({ a: 1 })).to.have.property('a');\n```\n\nWhen `val` is provided, `.property` also asserts that the property's value\nis equal to the given `val`. `val` can be an immutable collection.\n\n```js\nexpect(new Map({ a: 1 })).to.have.property('a', 1);\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nAdd `.nested` earlier in the chain to enable dot- and bracket-notation when\nreferencing nested properties. An immutable `List` can also be used as the\nstarting point of a `nested.property`.\n\n```js\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  'a.b[1]'\n);\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  'a.b[1]',\n  'y'\n);\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  ['a', 'b', 1],\n  'y'\n);\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  new List(['a', 'b', 1]),\n  'y'\n);\n```\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n```js\nexpect(Immutable.fromJS({ '.a': { '[b]': 'x' } })).to.have.nested.property(\n  '\\\\.a.\\\\[b\\\\]'\n);\n```\n\nAdd `.not` earlier in the chain to negate `.property`.\n\n```js\nexpect(new Map({ a: 1 })).to.not.have.property('b');\n```\n\nHowever, it's dangerous to negate `.property` when providing `val`. The\nproblem is that it creates uncertain expectations by asserting that the\ntarget either doesn't have a property at the given `path`, or that it\ndoes have a property at the given key `path` but its value isn't equal to\nthe given `val`. It's often best to identify the exact output that's\nexpected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn't expected to have a property at the given\n`path`, it's often best to assert exactly that.\n\n```js\nexpect(new Map({ b: 2 })).to.not.have.property('a'); // Recommended\nexpect(new Map({ b: 2 })).to.not.have.property('a', 1); // Not recommended\n```\n\nWhen the target is expected to have a property at the given key `path`,\nit's often best to assert that the property has its expected value, rather\nthan asserting that it doesn't have one of many unexpected values.\n\n```js\nexpect(new Map({ a: 3 })).to.have.property('a', 3); // Recommended\nexpect(new Map({ a: 3 })).to.not.have.property('a', 1); // Not recommended\n```\n\n`.property` changes the target of any assertions that follow in the chain\nto be the value of the property from the original target object.\n\n```js\nexpect(new Map({ a: 1 }))\n  .to.have.property('a')\n  .that.is.a('number');\n```\n\n### .size(value)\n\n- **@param** _{ Number }_ size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size(3);\n```\n\nIt can also be used as a chain precursor to a value comparison for the\n`size` property.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size.least(3);\nexpect(List.of(1, 2, 3)).to.have.size.most(3);\nexpect(List.of(1, 2, 3)).to.have.size.above(2);\nexpect(List.of(1, 2, 3)).to.have.size.below(4);\nexpect(List.of(1, 2, 3)).to.have.size.within(2, 4);\n```\n\nSimilarly to `length`/`lengthOf`, `sizeOf` is an alias of `size`:\n\n```js\nexpect(List.of(1, 2, 3)).to.have.sizeOf(3);\n```\n\n## TDD API Reference\n\n### .equal(actual, expected)\n\n- **@param** _{ Collection }_ actual\n- **@param** _{ Collection }_ expected\n\nAsserts that the values of `actual` are equivalent to the values of\n`expected`. Note that `.strictEqual()` and `.deepEqual()` assert\nexactly like `.equal()` in the context of Immutable data structures.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(1, 2, 3);\nassert.equal(a, b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`, `.strictEqual()` or `.deepEqual()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\n### .notEqual(actual, expected)\n\n- **@param** _{ Collection }_ actual\n- **@param** _{ Collection }_ expected\n\nAsserts that the values of `actual` are not equivalent to the values of\n`expected`. Note that `.notStrictEqual()` and `.notDeepEqual()` assert\nexactly like `.notEqual()` in the context of Immutable data structures.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(4, 5, 6);\nassert.notEqual(a, b);\n```\n\n### .sizeOf(collection, length)\n\n- **@param** _{ Collection }_ collection\n- **@param** _{ Number }_ size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nassert.sizeOf(List.of(1, 2, 3), 3);\nassert.sizeOf(new List(), 0);\n```\n","readmeFilename":"README.md","_id":"chai-immutable@2.0.0-rc.2","_npmVersion":"5.6.0","_nodeVersion":"8.11.2","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"integrity":"sha512-9DAbH5PsOSZGSJDskYb88GkFj2j5C9EbKMdR6apnF6iC0rIStwXH05EvcyruqHYe5Y1vQYmxOLFXyISS5L2KVw==","shasum":"b1e7f38f3ec403f64bee7ead29216d879e67279e","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-2.0.0-rc.2.tgz","fileCount":4,"unpackedSize":42035,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbDPQsCRA9TVsSAnZWagAAqfsP/2BgwWpaLPB3zBonXNyv\nVsD0YqPZNNVKdVo2RBRjBBVuHQI+Q9oxEBh/S+VEQ3K70q1Oyo93z0p2gSe0\nXgX9/GfNFyGVyr39LufCB2uKZggi2EMNbV9S0+2Jmi3yF39St9K+vp7I8AMe\nI5hnSYzcQFu/TRFrDSLtXcmWg0jJFDN9PK94btIUaNOcvIUeIYhLvqX1fRwv\nbSAVvDUslFU0/lFsknCias6N+DIR5k9px4mSeqf5+kKB1Vgd5i3DteIWiMKX\nf3HmitPJ6DGaMpNqv8UC2ddv5rOn1PNk3ZrHyuWW2Lb2HA8tS2z04Apn/p18\nNsQcyfOjaKvLlfPZeBSZIsiCFSLLmcovjw0+FVc1k/aC7bStfcP7VN691hSi\nT4VncRsQ96WwFgavXiZXP9vaGya+XW3R6W6TBmRCZyKKwm+ejhngBjRkT1z0\neNQhapEQWKrlRGBEWcfP8zgspIgPdGfTFEm/C3MtEYpNwisqFadhDXhRitn1\ncy/vR8INuW/LaqoEursVY+B7oEUNEfgaVmfS1Uhfzq1uFfpaztveIGXoRlPw\nxNhiLgEeAM2Hga2+I9py5ynohEHyhwyxfK2s+W7+yh/7QNqj9uxcQV1hkLKe\nIBIg/In1XY5bFAe/30pMMlVKpENwQTsomDuny6ADVCTffmz8MgDfuzFRXdJU\nXZG3\r\n=7k7j\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/chai-immutable_2.0.0-rc.2_1527575596474_0.1213936223970189"},"_hasShrinkwrap":false},"2.0.0-rc.3":{"name":"chai-immutable","version":"2.0.0-rc.3","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","scripts":{"format":"run-s -c \"lint:eslint --fix\" \"lint:prettier --write\"","lint:eslint":"eslint --ignore-path .gitignore . --report-unused-disable-directives","lint:prettier":"prettier --list-different \"**/*.{html,js,json,md,yml}\"","test":"run-s -c test:* lint:* eslint-check:*","test:readme":"mocha --compilers md:fulky/md-compiler README.md","test:mocha":"nyc mocha","coveralls":"nyc report --reporter=text-lcov | coveralls","eslint-check:main":"eslint --print-config .eslintrc.yml | eslint-config-prettier-check","eslint-check:test":"eslint --print-config test/.eslintrc.yml | eslint-config-prettier-check"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","engines":{"node":">=6"},"bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":"^4.0.0","immutable":"^3.0.0"},"devDependencies":{"chai":"4.2.0","coveralls":"3.0.2","eslint":"5.9.0","eslint-config-prettier":"3.2.0","eslint-plugin-chai-expect":"2.0.1","eslint-plugin-chai-friendly":"0.4.1","eslint-plugin-mocha":"5.2.0","fulky":"0.2.0","immutable":"3.8.2","mocha":"5.2.0","npm-run-all":"4.1.3","nyc":"13.1.0","prettier":"1.15.2"},"gitHead":"f8d4d9845c85cdd2e1c2832857de04e031081883","readme":"[![npm Version](https://img.shields.io/npm/v/chai-immutable.svg)](https://npmjs.org/package/chai-immutable)\n[![License](https://img.shields.io/npm/l/chai-immutable.svg)](LICENSE)\n[![Build Status](https://travis-ci.org/astorije/chai-immutable.svg?branch=master)](https://travis-ci.org/astorije/chai-immutable)\n[![Build Status](https://ci.appveyor.com/api/projects/status/407ts84pq7wd4kt9/branch/master?svg=true)](https://ci.appveyor.com/project/astorije/chai-immutable/branch/master)\n[![Coverage Status](https://coveralls.io/repos/astorije/chai-immutable/badge.svg)](https://coveralls.io/r/astorije/chai-immutable)\n[![devDependencies Status](https://david-dm.org/astorije/chai-immutable/dev-status.svg)](https://david-dm.org/astorije/chai-immutable?type=dev)\n[![peerDependencies Status](https://david-dm.org/astorije/chai-immutable/peer-status.svg)](https://david-dm.org/astorije/chai-immutable?type=peer)\n\n# Chai Immutable\n\nThis plugin provides a set of [Chai](http://chaijs.com/) assertions for [Facebook's Immutable library for JavaScript collections](http://facebook.github.io/immutable-js/).\n\n<!-- fulky:globals\nconst chai = require('chai');\nconst { assert, expect } = chai;\n\nconst Immutable = require('immutable');\nconst {\n  List,\n  Map,\n  Set,\n  Stack,\n} = Immutable;\n\nchai.use(require('./chai-immutable'));\n-->\n\n## Installation\n\n### Node.js\n\nInstall via [npm](http://npmjs.org) or [yarn](https://yarnpkg.com/):\n\n```bash\nnpm install --save-dev chai-immutable\nyarn add --dev chai-immutable\n```\n\n⚠️ **To use `chai-immutable` with Chai v4, you need to use\n`npm install --save-dev chai-immutable@next` (or\n`yarn add --dev chai-immutable@next`) instead, until I am done with the v2\nrelease of this plugin. I apologize for the inconvenience in the meantime.**\n\nYou can then use this plugin as any other Chai plugins:\n\n<!-- fulky:skip-test -->\n\n```js\nconst chai = require('chai');\nconst chaiImmutable = require('chai-immutable');\n\nchai.use(chaiImmutable);\n```\n\n### ES6 syntax (needs Babel transpiling)\n\n<!-- fulky:skip-test -->\n\n```js\nimport chai from 'chai';\nimport chaiImmutable from 'chai-immutable';\n\nchai.use(chaiImmutable);\n```\n\n### In the browser\n\nInclude this plugin after including Chai and Immutable. It will automatically\nplug in to Chai and be ready for use:\n\n```html\n<script src=\"chai-immutable.js\"></script>\n```\n\n### Using `chai-immutable` with other plugins\n\nIf you are using this plugin with\n[`chai-as-promised`](https://github.com/domenic/chai-as-promised/) or\n[`dirty-chai`](https://github.com/prodatakey/dirty-chai), note that\n`chai-immutable` must be loaded **before** any of them. For example:\n\n<!-- fulky:skip-test -->\n\n```js\nconst chai = require('chai');\nconst chaiAsPromised = require('chai-as-promised');\nconst chaiImmutable = require('chai-immutable');\nconst dirtyChai = require('dirty-chai');\nconst { expect } = chai;\n\nchai.use(chaiImmutable);\nchai.use(chaiAsPromised);\nchai.use(dirtyChai);\n\nconst { List } = require('immutable');\n\n/* ... */\n\nexpect(Promise.resolve(List.of(1, 2, 3))).to.eventually.have.size(3);\nexpect(true).to.be.true();\n```\n\n## BDD API Reference\n\n### .empty\n\nAsserts that the immutable collection is empty.\n\n```js\nexpect(List()).to.be.empty;\nexpect(List.of(1, 2, 3)).to.not.be.empty;\n```\n\n### .equal(collection)\n\n- **@param** _{ Collection }_ collection\n\nAsserts that the values of the target are equivalent to the values of\n`collection`. Aliases of Chai's original `equal` method are also supported.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(1, 2, 3);\nexpect(a).to.equal(b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\nAlso, note that `deep.equal` and `eql` are synonyms of `equal` when\ntested against immutable data structures, therefore they are aliases to\n`equal`.\n\n### .include(value)\n\n- **@param** _{ Mixed }_ val\n\nThe `include` and `contain` assertions can be used as either property\nbased language chains or as methods to assert the inclusion of a value or\nsubset in an immutable collection. When used as language chains, they toggle\nthe `contains` flag for the `keys` assertion.\n\nNote that `deep.include` behaves exactly like `include` in the context of\nimmutable data structures.\n\n```js\nexpect(new List([1, 2, 3])).to.include(2);\nexpect(new List([1, 2, 3])).to.deep.include(2);\nexpect(new Map({ foo: 'bar', hello: 'world' })).to.include('bar');\nexpect(new Map({ a: 1, b: 2, c: 3 })).to.include(new Map({ a: 1, b: 2 }));\nexpect(new Map({ foo: 'bar', hello: 'world' })).to.include.keys('foo');\n```\n\n### .keys(key1[, key2[, ...]])\n\n- **@param** _{ String... | Array | Object | Collection }_ key*N*\n\nAsserts that the target collection has the given keys.\n\nWhen the target is an object or array, keys can be provided as one or more\nstring arguments, a single array argument, a single object argument, or an\nimmutable collection. In the last 2 cases, only the keys in the given\nobject/collection matter; the values are ignored.\n\n```js\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys('foo', 'bar');\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new List(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Set(['bar', 'foo']));\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(new Stack(['bar', 'foo']));\nexpect(new List(['x', 'y'])).to.have.all.keys(0, 1);\n\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(['foo', 'bar']);\nexpect(new List(['x', 'y'])).to.have.all.keys([0, 1]);\n\n// Values in the passed object are ignored:\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys({ bar: 6, foo: 7 });\nexpect(new Map({ foo: 1, bar: 2 })).to.have.all.keys(\n  new Map({ bar: 6, foo: 7 })\n);\nexpect(new List(['x', 'y'])).to.have.all.keys({ 0: 4, 1: 5 });\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nBy default, the target must have all of the given keys and no more. Add\n`.any` earlier in the chain to only require that the target have at least\none of the given keys. Also, add `.not` earlier in the chain to negate\n`.keys`. It's often best to add `.any` when negating `.keys`, and to use\n`.all` when asserting `.keys` without negation.\n\nWhen negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\nexactly what's expected of the output, whereas `.not.all.keys` creates\nuncertain expectations.\n\n```js\n// Recommended; asserts that target doesn't have any of the given keys\nexpect(new Map({ a: 1, b: 2 })).to.not.have.any.keys('c', 'd');\n\n// Not recommended; asserts that target doesn't have all of the given\n// keys but may or may not have some of them\nexpect(new Map({ a: 1, b: 2 })).to.not.have.all.keys('c', 'd');\n```\n\nWhen asserting `.keys` without negation, `.all` is preferred because\n`.all.keys` asserts exactly what's expected of the output, whereas\n`.any.keys` creates uncertain expectations.\n\n```js\n// Recommended; asserts that target has all the given keys\nexpect(new Map({ a: 1, b: 2 })).to.have.all.keys('a', 'b');\n\n// Not recommended; asserts that target has at least one of the given\n// keys but may or may not have more of them\nexpect(new Map({ a: 1, b: 2 })).to.have.any.keys('a', 'b');\n```\n\nNote that `.all` is used by default when neither `.all` nor `.any` appear\nearlier in the chain. However, it's often best to add `.all` anyway because\nit improves readability.\n\n```js\n// Both assertions are identical\nexpect(new Map({ a: 1, b: 2 })).to.have.all.keys('a', 'b'); // Recommended\nexpect(new Map({ a: 1, b: 2 })).to.have.keys('a', 'b'); // Not recommended\n```\n\nAdd `.include` earlier in the chain to require that the target's keys be a\nsuperset of the expected keys, rather than identical sets.\n\n```js\n// Target object's keys are a superset of ['a', 'b'] but not identical\nexpect(new Map({ a: 1, b: 2, c: 3 })).to.include.all.keys('a', 'b');\nexpect(new Map({ a: 1, b: 2, c: 3 })).to.not.have.all.keys('a', 'b');\n```\n\nHowever, if `.any` and `.include` are combined, only the `.any` takes\neffect. The `.include` is ignored in this case.\n\n```js\n// Both assertions are identical\nexpect(new Map({ a: 1 })).to.have.any.keys('a', 'b');\nexpect(new Map({ a: 1 })).to.include.any.keys('a', 'b');\n```\n\nThe alias `.key` can be used interchangeably with `.keys`.\n\n```js\nexpect(new Map({ foo: 1 })).to.have.key('foo');\n```\n\n### .property(path[, val])\n\n- **@param** _{ String | Array | Iterable }_ path\n- **@param** _{ Mixed }_ val (optional)\n\nAsserts that the target has a property with the given `path`.\n\n```js\nexpect(new Map({ a: 1 })).to.have.property('a');\n```\n\nWhen `val` is provided, `.property` also asserts that the property's value\nis equal to the given `val`. `val` can be an immutable collection.\n\n```js\nexpect(new Map({ a: 1 })).to.have.property('a', 1);\n```\n\nNote that `deep.property` behaves exactly like `property` in the context of\nimmutable data structures.\n\nAdd `.nested` earlier in the chain to enable dot- and bracket-notation when\nreferencing nested properties. An immutable `List` can also be used as the\nstarting point of a `nested.property`.\n\n```js\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  'a.b[1]'\n);\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  'a.b[1]',\n  'y'\n);\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  ['a', 'b', 1],\n  'y'\n);\nexpect(Immutable.fromJS({ a: { b: ['x', 'y'] } })).to.have.nested.property(\n  new List(['a', 'b', 1]),\n  'y'\n);\n```\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by\nadding two backslashes before them.\n\n```js\nexpect(Immutable.fromJS({ '.a': { '[b]': 'x' } })).to.have.nested.property(\n  '\\\\.a.\\\\[b\\\\]'\n);\n```\n\nAdd `.not` earlier in the chain to negate `.property`.\n\n```js\nexpect(new Map({ a: 1 })).to.not.have.property('b');\n```\n\nHowever, it's dangerous to negate `.property` when providing `val`. The\nproblem is that it creates uncertain expectations by asserting that the\ntarget either doesn't have a property at the given `path`, or that it\ndoes have a property at the given key `path` but its value isn't equal to\nthe given `val`. It's often best to identify the exact output that's\nexpected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn't expected to have a property at the given\n`path`, it's often best to assert exactly that.\n\n```js\nexpect(new Map({ b: 2 })).to.not.have.property('a'); // Recommended\nexpect(new Map({ b: 2 })).to.not.have.property('a', 1); // Not recommended\n```\n\nWhen the target is expected to have a property at the given key `path`,\nit's often best to assert that the property has its expected value, rather\nthan asserting that it doesn't have one of many unexpected values.\n\n```js\nexpect(new Map({ a: 3 })).to.have.property('a', 3); // Recommended\nexpect(new Map({ a: 3 })).to.not.have.property('a', 1); // Not recommended\n```\n\n`.property` changes the target of any assertions that follow in the chain\nto be the value of the property from the original target object.\n\n```js\nexpect(new Map({ a: 1 }))\n  .to.have.property('a')\n  .that.is.a('number');\n```\n\n### .size(value)\n\n- **@param** _{ Number }_ size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size(3);\n```\n\nIt can also be used as a chain precursor to a value comparison for the\n`size` property.\n\n```js\nexpect(List.of(1, 2, 3)).to.have.size.least(3);\nexpect(List.of(1, 2, 3)).to.have.size.most(3);\nexpect(List.of(1, 2, 3)).to.have.size.above(2);\nexpect(List.of(1, 2, 3)).to.have.size.below(4);\nexpect(List.of(1, 2, 3)).to.have.size.within(2, 4);\n```\n\nSimilarly to `length`/`lengthOf`, `sizeOf` is an alias of `size`:\n\n```js\nexpect(List.of(1, 2, 3)).to.have.sizeOf(3);\n```\n\n## TDD API Reference\n\n### .equal(actual, expected)\n\n- **@param** _{ Collection }_ actual\n- **@param** _{ Collection }_ expected\n\nAsserts that the values of `actual` are equivalent to the values of\n`expected`. Note that `.strictEqual()` and `.deepEqual()` assert\nexactly like `.equal()` in the context of Immutable data structures.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(1, 2, 3);\nassert.equal(a, b);\n```\n\nImmutable data structures should only contain other immutable data\nstructures (unlike `Array`s and `Object`s) to be considered immutable and\nproperly work against `.equal()`, `.strictEqual()` or `.deepEqual()`. See\n[this issue](https://github.com/astorije/chai-immutable/issues/24) for\nmore information.\n\n### .notEqual(actual, expected)\n\n- **@param** _{ Collection }_ actual\n- **@param** _{ Collection }_ expected\n\nAsserts that the values of `actual` are not equivalent to the values of\n`expected`. Note that `.notStrictEqual()` and `.notDeepEqual()` assert\nexactly like `.notEqual()` in the context of Immutable data structures.\n\n```js\nconst a = List.of(1, 2, 3);\nconst b = List.of(4, 5, 6);\nassert.notEqual(a, b);\n```\n\n### .sizeOf(collection, length)\n\n- **@param** _{ Collection }_ collection\n- **@param** _{ Number }_ size\n\nAsserts that the immutable collection has the expected size.\n\n```js\nassert.sizeOf(List.of(1, 2, 3), 3);\nassert.sizeOf(new List(), 0);\n```\n","readmeFilename":"README.md","_id":"chai-immutable@2.0.0-rc.3","_npmVersion":"6.4.1","_nodeVersion":"8.12.0","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"integrity":"sha512-1/7cJ+FCL1yWeelCM7rhLpSQ8/PhIOg3SE8khF7bRQ/6KbJ+Y04TmTdc1aKRFcNzj+i3DMV5nfhBqvxOROAuVw==","shasum":"1277c24ced61cba2a691b711a7ad63944779643b","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-2.0.0-rc.3.tgz","fileCount":4,"unpackedSize":42484,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb57uyCRA9TVsSAnZWagAA8rcP/0JtTK5jCzeqe6ajBgrH\nDJRQwSU2uAtjsdoxl8K+NWLe/xCtYSZf6NJcvm0QNk094w8JVGnUCmBb16A/\niVaOiSqVWFaaVzjR940JsQX1JwwsgUfH1VupPcth+gMVVLtMMExRlgz7BOVa\nk2gAoBeRUfqdtZXVCHQsVuabCk6NQF/CnRV5qrAx5xapIlMZO9TUitgqZBx+\nEEIAOLknAlvB9nk70YY30RpElhYpAHGh8/EAdx5JkGeyh+1I6+2sL2vQHH63\nFTSI84M3pMz1JNQefEeLk0AUmHBro7CBdn9Iqbl6xl7ICV4PifTWGhWAvWjw\nts5VBT2KayTXtKywAGmhtuX/9URM3uqiH7R2akXiXEwdHiVV7KykJkd+iX0X\nIF5tW1d8MWeX8HMtMqJ6rVMejRzMdzXYCwaFckfgDk9JQ4GSVb7hNsEXZrbw\nriOgZdUFXHQQxmiZxMRofCh6P9SYdw+S8R2o5GRennbliyuDGFgNfF4MdnBC\nQw7p2HFffBmcvTrg1/+Yw4OG5KvRbDT3qcukdRR+YMJmYb86svKxdH9EURQt\n6ArpImmOTGk3heLLLw88JPspWRNOcLyqznODBYbAol9LKbw6Ns2xcoUHOV3U\nxibMwC22yZqvQVt6P8omJLT9xVGfPXDq8If83AOaXVDC3QwdhXQXn4VC1nWz\nNUof\r\n=zWxE\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/chai-immutable_2.0.0-rc.3_1541913521780_0.8154736287440874"},"_hasShrinkwrap":false},"2.0.0":{"name":"chai-immutable","version":"2.0.0","description":"Chai assertions for Facebook's Immutable library for JavaScript collections","main":"chai-immutable.js","scripts":{"format":"run-s -c \"lint:eslint --fix\" \"lint:prettier --write\"","lint:eslint":"eslint --ignore-path .gitignore . --report-unused-disable-directives","lint:prettier":"prettier --list-different \"**/*.{html,js,json,md,yml}\"","test":"run-s -c test:* lint:* eslint-check:*","test:readme":"mocha --require fulky/md-compiler README.md","test:mocha":"nyc mocha","coveralls":"nyc report --reporter=text-lcov | coveralls","eslint-check:main":"eslint --print-config .eslintrc.yml | eslint-config-prettier-check","eslint-check:test":"eslint --print-config test/.eslintrc.yml | eslint-config-prettier-check"},"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"license":"MIT","engines":{"node":">=6"},"bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"homepage":"https://github.com/astorije/chai-immutable","peerDependencies":{"chai":"^4.0.0","immutable":"^3.0.0"},"devDependencies":{"chai":"4.2.0","coveralls":"3.0.3","eslint":"5.15.3","eslint-config-prettier":"4.1.0","eslint-plugin-chai-expect":"2.0.1","eslint-plugin-chai-friendly":"0.4.1","eslint-plugin-mocha":"5.3.0","fulky":"0.2.0","immutable":"3.8.2","mocha":"6.0.2","npm-run-all":"4.1.5","nyc":"13.3.0","prettier":"1.16.4"},"gitHead":"a534fae676bbfc7cab7ee945621c8fbc0b5bc931","_id":"chai-immutable@2.0.0","_npmVersion":"6.4.1","_nodeVersion":"8.15.1","_npmUser":{"name":"astorije","email":"jeremie@astori.fr"},"dist":{"integrity":"sha512-TzmohCPesJzmNaEBogmbm96RQUdwKBypFEKo2tLolB/P0p+o9q1j5qi5LmkhxqJp32utnxLbHkLjdgRSgeGhkw==","shasum":"458621219b1029651ca8a0471c463d7af28f0910","tarball":"https://registry.npmjs.org/chai-immutable/-/chai-immutable-2.0.0.tgz","fileCount":4,"unpackedSize":42210,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJckF8/CRA9TVsSAnZWagAApMsQAJC4EgwR5U8W7xokaam8\nzRGRL5qe1omZ11RT47DLZIa9YHQCsWChr5tKYJAnW+jsGloGiIw3s1i6NR8a\nwiQZMOtJccaGiYdJcngbTHja2v9GxdGS90gJbAKKvSZ92aAq0z6l2H9QWBTn\nazZHAeXAkjytkWGNxeZwymwdi7Ye/pGVR0i2n5vRfDAhhX4aETEMcvu2oCdg\nwq6HITPwexosATrzrZN3EcG4eaoFsYo/4Y5IoE18nvF8vaAOKoAUDDj3v4oI\n6ekkwIgaVXwCWUI3k14V1ncrcj5JoQr00SKW1+iXVBcGtG0eoO1kP143cogM\n4u8fzfsNfAtyRULQpDJpGhEBqa3MyPs54XsPtw2yq0jgT7bRtzbbJINUD8ye\nSfWO1xu1+NKnSocQR75hPgYrB5MHehcYc2SGoF2xJ5usSfSFIx0O4RuCPrsP\nRA6tpZXqPB5y8WuJGHS7Mit5TW4p8rwJ5ZdoJxnG23842p7gvXY85vebdyI8\nkdOLyEGIaW/VQXbuLSVbPSErSo+UF0DbAQul7OsqRCfDbcMcqKM//6mV2Tti\nulKZMjYxYd7rcApY0fvPZ5RPiEEYCLXLKlet1WtdpGGO1mJdBLaMpcI1s941\nn6Qdx2xD71C6hr/lv/fbX+0jQeR6RAqUCZBWc1i40f3vAseJ/gEwRNqR8lR2\ntCcM\r\n=fvLR\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"astorije","email":"jeremie@astori.fr"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/chai-immutable_2.0.0_1552965438895_0.7487047618663749"},"_hasShrinkwrap":false}},"homepage":"https://github.com/astorije/chai-immutable","keywords":["chai","chai-plugin","browser","test","assertions","immutable"],"repository":{"type":"git","url":"git+https://github.com/astorije/chai-immutable.git"},"author":{"name":"Jérémie Astori","url":"https://jeremie.astori.fr"},"bugs":{"url":"https://github.com/astorije/chai-immutable/issues"},"license":"MIT","readmeFilename":"README.md","users":{"freebird":true,"langri-sha":true}}